[{"authors":null,"categories":null,"content":"I am a mathematician with a strong interest in computer science and programming.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://andreweltsch.com/author/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/admin/","section":"author","summary":"I am a mathematician with a strong interest in computer science and programming.","tags":null,"title":"","type":"author"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"","permalink":"https://andreweltsch.com/author/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/","section":"author","summary":"","tags":null,"title":"Authors","type":"author"},{"authors":null,"categories":null,"content":"Required Knowledge You should know what a directed graph is.\nIntroduction This post is part of a series on algorithms related to topological sorting. In this particular post I want to give a short introduction to the concept of a topological sort. Additionally I will present Kahn's algorithm, which topologically sorts a given directed graph.\nThe Basics We start with a definition from Introduction to Algorithms1.\n A topological sort of a directed acyclic graph $D=(V,A)$ is a linear ordering of the vertices, s.t. for any edge $(u, v) \\in A$, the node $u$ needs to appear before $v$ in the ordering.\n Not all directed graphs can be topologically sorted.\n A directed graph $G$ is acyclic if and only if it can be topologically sorted.\n Therefore algorithms for topological sorting can often be used to check if a graph contains cycles.\nThere are two well-known algorithms to find a topological sort of a graph. One is based on depth-first search (DFS) and another one is based on node degrees in the graph. The algorithm based on node degrees was developed by Kahn2.\nKahn's Algorithm Only nodes that have no predecessor can be in the first position of the ordering. Thus you need to start in a node that has no incoming edges. After choosing an initial node, we can remove it from the graph and start the search for another node without incoming edges.\nThis can easily be achieved by maintaining a map of the node degrees.\ndef kahns_algo(graph): \u0026quot;\u0026quot;\u0026quot;Calculate a topological sort of a given directed graph using Kahn's algorithm [1]. graph : (DirectedGraph) a directed graph raises : Exception if the graph contains a cycle References ---------- [1] Kahn, Arthur B. \u0026quot;Topological sorting of large networks.\u0026quot; Communications of the ACM 5.11 (1962): 558-562. \u0026quot;\u0026quot;\u0026quot; # initialize degree map degrees = {} zero_nodes = [] top_sort = [] for u in graph.get_nodes(): pred = graph.get_predecessors(u) degrees[u] = len(pred) if len(pred) == 0: zero_nodes.append(u) while len(zero_nodes) \u0026gt; 0: u = zero_nodes.pop() top_sort.append(u) for v in graph.get_successors(u): degrees[v] -= 1 if degrees[v] == 0: zero_nodes.append(v) if len(top_sort) \u0026lt; len(graph.get_nodes()): raise Exception(\u0026quot;Graph contains a cycle\u0026quot;) return top_sort  Randomized Testing To increase the confidence in our implementation we can perform the usual unit tests by comparing the output of the algorithm against known examples. Another way is to use randomized testing. If we can generate random problem instances and have a reliable test to check if the solution returned by our algorithm is correct, we can use this routine to test the algorithm on all sorts of instances.\nIn our case we can directly use the definition of a topological sort to create such a checking routine. Now for any ordering of the nodes we can create an index that maps the node id to its position in the ordering. Then we can go over all of the edges and check if the position of the start node is smaller than the position of the end node. This results in the following algorithm:\ndef is_topological_sort(graph, sequence): \u0026quot;\u0026quot;\u0026quot;Check if a given sequence is a topological sort of a directed graph. graph : (DirectedGraph) a directed graph sequence : (iterable[node]) a sequence of nodes in the graph, will be checked if it fulfills the topological sorting condition \u0026quot;\u0026quot;\u0026quot; if set(sequence) != set(graph.get_nodes()): return False index = {v: i for (i, v) in enumerate(sequence)} return all(index[u] \u0026lt; index[v] for (u, v) in graph.get_edges())  To generate a random instance of a directed acyclic graph on $n$ nodes, we can choose random pairs from \\( \\{(i, j) \\,|\\, i, j \\in \\mathbb{N} : 0 \\leq i and add these as edges to a graph on the nodes \\(V = \\{0, \\ldots, n-1\\}\\). Each directed acyclic graph has a topological sort, so it is isomorphic to a graph that can described by the construction above. Thus it is possible to generate any directed acyclic graph with this method.\ndef random_dag(n_nodes, edge_threshold=0.5): \u0026quot;\u0026quot;\u0026quot;Create a random directed acyclic graph with n_nodes nodes. n_nodes : (int) number of nodes in the graph edge_threshold : (float) value between 0 and 1, take edge (i, j) if random() \u0026gt; edge_threshold \u0026quot;\u0026quot;\u0026quot; dag = DirectedGraph() edges = [] for u in range(n_nodes): for v in range(u+1, n_nodes): if random() \u0026gt; edge_threshold: dag.add_edge(u, v) return dag  A complete implementation of this algorithm (i.e. including a graph class and tests), can be found here.\n  Cormen, T. H., Leiserson, C. E., Rivest, R. L., \u0026amp; Stein, C. (2009). Introduction to algorithms. MIT press. ^ Kahn, A. B. (1962). Topological sorting of large networks. Communications of the ACM, 5(11), 558-562. ^   ","date":1567900800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567900800,"objectID":"600a87be32a9be53f1509cd01b0addb4","permalink":"https://andreweltsch.com/post/top-sort-1/","publishdate":"2019-09-08T00:00:00Z","relpermalink":"/post/top-sort-1/","section":"post","summary":"In this post I will give a very short introduction into topological sorting \nof a directed graph. I will also cover randomized testing of the algorithm.\n","tags":["post","graph theory","topological sorting"],"title":"Topological Sorting","type":"post"},{"authors":["admin"],"categories":null,"content":"","date":1544137200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1544137200,"objectID":"b01146d81e3156758501b9aa2639e71e","permalink":"https://andreweltsch.com/publication/masters-thesis/","publishdate":"2018-12-07T00:00:00+01:00","relpermalink":"/publication/masters-thesis/","section":"publication","summary":"In this thesis, we study transient (time-dependent) gas flow in natural gas networks with\na focus on passive gas networks. We compare different algorithms to approximate flow\nand pressure values in a gas network.\nA gas network consists of pipelines that deliver gas from suppliers to consumers. The\ngas flow in a pipe can be described by the Euler Equations which are a set of nonlinear\npartial differential equations. We use the so-called friction-dominated model to simplify\nthe gas flow equations and apply an implicit box scheme to derive a suitable discretization.\nWe compare different linearization methods to solve the resulting nonlinear system of\nequations.\nWe introduce six known mixed-integer formulations for piecewise linear functions and\ndescribe how to use these formulations to approximate the nonlinear functions in the gas\nflow model.\nFurther, we develop an iterative method, to solve the pipe flow system. We call the\nmethod “iterative velocity approximation”, and it is based on a linearization of the\nmomentum equation. We linearize the equation by fixing the absolute gas flow velocity.\nWe show convergence on single pipes.\nWe evaluate and compare the performance of generic nonlinear solvers, the piecewise\nlinear approximations and the iterative velocity approximation on nine different networks.","tags":[],"title":"Master's Thesis","type":"publication"},{"authors":null,"categories":null,"content":"Introduction Probably everyone that has dived into the world of custom mechanical keyboards, learns pretty fast that almost any aspect of a keyboard can be customized. This includes the arrangement of letters on the keyboard, we refer to this as the keyboard layout. There are already plenty of alternative layouts (Dvorak, Colemak, etc.), but often these are based only loosely on letter frequency and hand ergonomics.\nThe purpose of this post is not to advertise some shiny new layout, but to give people the chance to find an optimal keyboard layout for their own needs.\nWhile I was comparing different layouts I stumbled upon the Colemak Mod-DH layout which uses a mathematical model to compare well-known layouts. As I was reading about the model, I wondered if it is possible to find a provably optimal layout according to this particular model.\nEventhough the sheer number of possible layouts prohibits enumeration, the answer fortunately is still \u0026quot;YES\u0026quot;. The model can be formulated as an integer program. These kind of mathematical optimization problems have a strong theoretical foundation and have powerful solvers available.\nThe Model In this section I want to first describe the model informally and in the second part I will precisely introduce variables/constraints that fit the description.\nThe informal description The model is based on a rather intuitive and simple categorization of the keys. For each key on the keyboard we define a value which is supposed to estimate how hard it is to press the corresponding key. In our model higher values correspond to harder to reach keys. What we try to achieve with this is that common letters like 'T' or 'E' will be assigned to keys that are easy to reach.\nAnother thing we care about is so-called 'bigrams'. The word bigrams refers to combinations of two letters, examples might be 'th', 'he', 'ou', etc. To achieve better speed and ergonomics we want to minimize finger travel, so any bigram in which we have to use the same finger for both letters will be penalized by an appropriate factor. Similarly we apply a penalty for pinky-ring-finger bigrams and ring-middle-finger bigrams.\nThe formal model We will start with a list of some definitions\n $K$ is the set of available keys $S$ is the set of symbols we want to assign $F$ is the set of fingers we have $R = \\{0, \\ldots, r_{\\max}\\}$ is the set of rows $f : K \\to F$ is a function that assigns a unique finger to each key $r : K \\to R$ is a function that assigns a row to each key  For each key $k \\in K$ and each symbol $s \\in S$ we introduce a binary variable $v_{k,s}$ that indicates if the the symbol $s$ is assigned to key $k$:\n\\[ \\forall k \\in K, s \\in S : v_{k,s} \\in \\{0,1\\} \\]\nWith these variables we are finally able to formulate the constraints that define a valid layout assignment. The first constraint will be that every symbol is assigned to exactly one key.\n\\[ \\sum_{k \\in K} v_{k,s} = 1, \\, \\forall s \\in S \\]\nAlso we need to add a constraint that limits the number of symbols to one symbol per key.\n\\[ \\sum_{s \\in S} v_{k,s} \\leq 1, \\, \\forall k \\in K \\]\nDefining bigram variables Now we need to consider the bigram penalties. In order to account for these bigram penalties, we introduce variables for each bigram $(s, t) \\in S \\times S$ and each (relevant) key combination $(k, l) \\in K \\times K$. In our case a relevant key combination is a combination of two keys, in which both keys correspond to the same finger (same-finger bigram), one key is assigned to a pinky and the other key is assigned to the ring finger of the same hand (pinky-ring bigram) or one key is assigned to a ring finger and the other one to a middle finger of the same hand (ring-middle bigram). For notation purposes we define the left and right pinky finger $p_l, p_r \\in F$, the left and right ring finger $r_l, r_r \\in F$ and the left and right middle finger $m_l, m_r \\in F$.\nIn order to make the constraint on key combinations easier to write, we introduce the following short-hand notation:\n\\[ q_{f_1,f_2}(k,l) := (f(k) = f_1 \\land f(l) = f_2) \\lor (f(k) = f_2 \\land f(l) = f_1) \\]\nThis is expression is true if the keys $k, l \\in K$ are assigned to the fingers $f_1, f_2 \\in F$.\nWe can use this to define the following sets of key combinations:\n\\[ B_{\\text{same}} = \\{ (k,l) \\in K^2 | \\exists f \\in F : q_{f,f}(k,l) \\} \\\\ B_{\\text{pinky-ring}} = \\{ (k,l) \\in K^2 | q_{p_l,r_l}(k,l) \\lor q_{p_r,r_r}(k,l) \\} \\\\ B_{\\text{ring-middle}} = \\{ (k,l) \\in K^2 | q_{r_l,m_l}(k,l) \\lor q_{r_r,m_r}(k,l) \\} \\]\nFinally we introduce binary variables for the bigrams\n\\[ \\forall (k,l) \\in B_{\\text{same}}, (s,t) \\in S^2 : x_{k,l,s,t} \\in \\{0,1\\}\\\\ \\forall (k,l) \\in B_{\\text{pinky-ring}}, (s,t) \\in S^2 : y_{k,l,s,t} \\in \\{0,1\\}\\\\ \\forall (k,l) \\in B_{\\text{ring-middle}}, (s,t) \\in S^2 : z_{k,l,s,t} \\in \\{0,1\\} \\]\nIn order to force a bigram variable to be $1$ iff the current assignment contains the bigram, we add the following constraints to the program:\n\\[ v_{k,s} + v_{k,t} + v_{l,s} + v_{l,t} - x_{k,l,s,t} \\leq 1, \\, \\forall (k,l) \\in B_{\\text{same}}, \\, (s,t) \\in S^2 \\\\ v_{k,s} + v_{k,t} + v_{l,s} + v_{l,t} - y_{k,l,s,t} \\leq 1, \\, \\forall (k,l) \\in B_{\\text{pinky-ring}}, \\, (s,t) \\in S^2 \\\\ v_{k,s} + v_{k,t} + v_{l,s} + v_{l,t} - z_{k,l,s,t} \\leq 1, \\, \\forall (k,l) \\in B_{\\text{ring-middle}}, \\, (s,t) \\in S^2 \\\\ \\]\nTo highlight why this works, consider the following arguments for some bigram $s, t$ and keys $k, l$. From our previous constraints we know that each symbol can only be assigned to a single key. Thus the maximum of the sum\n\\[ v_{k,s} + v_{k,t} + v_{l,s} + v_{l,t} \\]\nis 2, in fact it is 2 if and only if the symbol assignment contains the bigram $s,t$. So only in this case\n\\[ x_{k,l,s,t} \\]\nhas to be equal to one. We also know that we assign a non-negative weight to this variable in the objective function. We want to minimze our objective, so it is safe to assume, that in an optimal solution the variable is only one, if the corresponding bigram exists.\nThe objective function Now it is time to specify the objective function, therefore we define some parameters:\n $f_s$ symbol frequency for each symbol $s \\in S$ $g_{s,t}$ bigram frequency for each bigram $(s, t) \\in S$ $c_{k}$ key penalty for each key $k \\in K$ $a_i$ same-finger bigram penalty for row difference $i \\in R$ $b_i$ pinky-ring bigram penalty for row difference $i \\in R$ $c_i$ ring-middle bigram penalty for row difference $i \\in R$  Finally we can combine the variables and parameters to define the objective\n\\[\\begin{eqnarray} \\min_{v,x,y,z} \u0026 \\sum_{s \\in S} \\sum_{k \\in K} f_s \\cdot c_k \\cdot v_{k,s}\\\\ +\u0026 \\sum_{(s, t) \\in S^2}\\sum_{(k,l) \\in B_{\\text{same}}} g_{s,t}\\cdot a_{|r(k) - r(l)|}\\cdot x_{k,l,s,t} \\\\ +\u0026 \\sum_{(s, t) \\in S^2}\\sum_{(k,l) \\in B_{\\text{pinky-ring}}} g_{s,t}\\cdot b_{|r(k) - r(l)|}\\cdot y_{k,l,s,t} \\\\ +\u0026 \\sum_{(s, t) \\in S^2}\\sum_{(k,l) \\in B_{\\text{ring-middle}}} g_{s,t}\\cdot c_{|r(k) - r(l)|}\\cdot z_{k,l,s,t} \\end{eqnarray}\\]\nSpeed-Ups and Trade-Offs There are many binary variables in the above program; with commercial solvers, solving a typical instance, usually works really well and is fast, but if you are using an open-source solver, it might make sense to apply some modifications to get good results fast.\nThe biggest problem are the bigrams, they introduce a variable for each bigram and two related keys. By using only the relevant bigrams you can reduce the number of variables drastically. One way to do this is to take only the most frequent bigrams that make up the major percentage of all bigrams (for example 99%).\nAnother improvement might be to consider symmetries in the layout. For example matrix layouts usually are symmetric between both hands, meaning that each solution has a corresponding solution that is mirrored. In cases like this it might be a good idea to assign the most frequent key to one side.\nResults I implemented the model in python using the Pyomo optimization library. My implementation can be found here.\nAn optimal layout for the standard values from the Mod-DH homepage:\n   col0 col1 col2 col3 col4 col5 col6 col7 col8 col9     x c l m j / f u , q   o s r t v p n e a i   z g w d k b h y . ;    ","date":1532606400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532606400,"objectID":"0b9bc55456d358e8253fa606ff72b182","permalink":"https://andreweltsch.com/post/layout-optimization/","publishdate":"2018-07-26T12:00:00Z","relpermalink":"/post/layout-optimization/","section":"post","summary":"In this post I will explore an integer programming formulation for finding an optimal keyboard layout.\n","tags":["post","integer programming","linear programming","keyboards","optimization"],"title":"Finding an Optimal Keyboard Layout","type":"post"},{"authors":["admin"],"categories":null,"content":"","date":1464818400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1464818400,"objectID":"39991e13feb6a917e0b638d49d5498db","permalink":"https://andreweltsch.com/publication/bachelors-thesis/","publishdate":"2016-06-02T00:00:00+02:00","relpermalink":"/publication/bachelors-thesis/","section":"publication","summary":"The thesis gives a detailed description and analysis of a randomized\nalgorithm from\n\"Affine Projections of polynomials\" (Kayal, 2012)\nwhich can be used to solve the equivalence problem for the determinant polynomial\nin polynomial time.\n","tags":[],"title":"Bachelor's Thesis","type":"publication"}]